# -*- coding: utf-8 -*-
"""Copia 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uVOegNScR4NvJZRqHzeqnAkm5K-dOH1v

# Introducción a la programación - Señales y Sistemas

- ## [Librería numpy](https://numpy.org/) (señales digitales discretas)

- ## [Librería sympy](https://www.sympy.org/es/) (emular señales continuas)
"""

import numpy as np # importar libreria numpy
x = 30 #tipo int
y = 36.5 #tipo float

print(type(x),type(y)) #imprimir en pantalla

"""# Arreglo de datos en numpy

- Señales en continuo

  $x(t) \in \mathbb{R}, \mathbb{C}$

  $t \in \mathbb{R}$

- Señales discretas

  $x[t_k] \in \mathbb{R}, \mathbb{C}$  

  $t \in \{t_0,t_1,\dots,t_{K-1}\}$; $K \in \mathbb{N}$ muestras

- Señales digitales

  $x[t_k] \in \{x_0,x_1,\dots,x_{P-1}\};$ $P\in \mathbb{N}$ estados según cantidad de bits del sistema de proceso

  $t \in \{t_0,t_1,\dots,t_{K-1}\}$; $K \in \mathbb{N}$ muestras
"""

xv = np.array([0,-2.5,10]) #crear array tipo vector
xv

"""# Listas vs numpy array

- Las listas pueden contener, números, strings, y en general objetos

- Los array de numpy están pensados para procesar números (matrices, tensores).
"""

xl = [0,-2,0.5] # no es señal digital -> lista de números
xl

xl = ['andres marino',0.5, 2] #lista de tres elementos con un string, un flotante y un entero
xl

"""# Tamaños, indexación y graficar numpy array"""

xv.shape # vector con 3 elementos - > shape retorna la forma (tamaño del arreglo)

xm = np.array([[0,-2.5,10,4],[6,47,70,2],[8,10.2,-698,-0.9]]) #cada lista de números es tratada como una fila de la matriz
xm

xm.shape

"""# En python se indexa desde 0"""

xv = np.array([-6,5,4.2,3,8,50,16])
print(xv,xv.shape,xv[0])

"""# En Python, cuando se indexa por rangos de valores, no se incluye el último elemento

x[t_i,t_f)
"""

xv[1:5] # x[t_0] # no se incluye el elemento 5 que equivale a x[5] = 50

"""*Cuando se piden todos los elementos hasta el final con el operador : si se incluye el último elemento*"""

# desde el segundo elemento hasta el ultimo
print(xv)
print(xv[1:])

#desde antes del tercer elmento hasta el principio
print(xv)
print(xv[:3])

"""# Para matrices se extiende la misma sintaxis para indexar vectores, pero separando la indexación por filas y por columnas"""

print(xm)

xm[1:2,:4]

xm[0:2,0]

xm[0,1:]

np.diag(xm)#diagonal del arreglo (matriz)

"""# Simular cero y pendiente  para acondicionamiento de señales

- Se generará una función para emular el proceso de cero y pendiente en el acondicionamiento de señales.

- Las funciones principales para generar vectores equiespaciados son [linspace](https://numpy.org/doc/stable/reference/generated/numpy.linspace.html), [range](https://www.w3schools.com/python/ref_func_range.asp) y [arange](https://numpy.org/doc/stable/reference/generated/numpy.arange.html)
"""

# crear vector tiempo por rango y por número de muestras
K = 200 # número de muestras
ti = -15 # tiempo incial referencia [s]
tf = 10 # tieimpo final  [s]
# vector de tiempo equiespacioado
tv = np.linspace(ti,tf,K)
print(tv)
print(tv.shape)
# tiempo muestreo se define según el rango de trabajo en segundos y la cantidad de muestras
Ts = (tf - ti)/K
print(Ts)

"""- Supongamos la función cuadrática:

$x(t) = a t^2 + b;$

$\forall t \in [t_i,t_f]$

- Se pretende generar el proceso de discretización según:

$x[t_k] = a t_k^2 + b$




"""

#parámetros parabola
a = 4
b = -3
xv = a*(tv**2) + b # creamos parabola en tiempo discreto-> **  pontencia
print(xv)
print(xv.shape)

## Basicamente se creo una parabola de la forma: 4*(x**2)+ b

import matplotlib.pyplot as plt #librería para gráficas básicas en python

plt.plot(tv,xv,'r |') #vector en eje horizontal, vector eje vertical, color y marcador
plt.xlabel('tiempo [s]')
plt.ylabel('$x[t_k]$') # $ $ ecuación latex
plt.show() #mostrar gráfica

"""## Cálculo de pendiente y del offset (cero)

$$ y[t_k] \in [y_{min},y_{max}]$$

$$y[t_k] = m x[t_k] + c$$

$$m = \frac{y_{max}-y_{min}}{x_{max}-x_{min}}$$

$$c = y[t_k] - m x[t_k]$$

- Se crea un código tipo función bajo el ambiente def, para generar el cero y pendiente según los valores $y_{max}$ y $y_{min}$ definidos por el usuario.
"""

y_min = 0 # valor min después de cero y pendiente
y_max = 5 # valor max después de cero y pendiente
#crear funcion en python
def my_ceropen(x,ymin = -5, ymax = 5): #en general se pueden definir valores por defecto
  '''
  Codigo base para simular proceso de cero y pendiente
  Se ingresa arreglo de numpy y los valores min  y max despues de cero y pendiente
  '''
  xmax = max(x) # x.max()
  xmin = min(x) # x.min()
  m = (ymax - ymin)/(xmax - xmin)
  c = ymin - m*xmin
  yv = m*x + c
  return yv

yv = my_ceropen(xv,ymin=-15,ymax=20) #se llama la función definida en la celda anterior

print(yv)
print(yv.shape)

"""- Se grafican la señal original y la señal acondicionada mediante [subplot](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.subplot.html)"""

plt.subplot(121) # 1 = #filas, 2 = #columnas, 1 = # dibujo
plt.plot(tv,xv,'r.')
plt.xlabel('tiempo [s]')
plt.ylabel('$x[t_k]$')

plt.subplot(122)
plt.plot(tv,yv,'b.')
plt.xlabel('tiempo [s]')
plt.ylabel('$y[t_k]$')
plt.subplots_adjust(hspace=0.5,wspace=0.5) #ajustar espaciado entre gráficas
plt.show()

plt.plot(tv,xv,'r.')
plt.xlabel('tiempo [s]')
plt.ylabel('$x[t_k]$')

plt.plot(tv,yv,'b.')
plt.xlabel('tiempo [s]')
plt.ylabel('$y[t_k]$')

"""- Se ilustra nuevamente el proceso de acondicionamiento cero y pendiente utilizando una función seno:

$$x[t_k] = A \sin[w_o t + \phi]$$

$$x[t_k] = A \sin[2 \pi F_o t] = A \sin[2 \pi t / T_o ]$$


"""

K = 500 # número de muestras
T_o = 1/60 # periodo función sin
A = 120 # amplitud
ti = 4*T_o #tiempo inicial
tf = T_o #tiempo final
tv = np.linspace(ti,tf,num=K) #vector de datos en tiempo
xv = A * np.sin(2*np.pi*tv/T_o) #vector de amplitud
#print (tv)
plt.plot(tv,xv)
plt.xlabel('tiempo [s]')
plt.ylabel('$A\sin[\omega t_k]$')
plt.show()

yv = my_ceropen(xv,ymin=0,ymax=5) #se utiliza la función ya creada de cero y pendiente

plt.subplot(121) # 1 = #filas, 2 = #columnas, 1 = # dibujo
plt.plot(tv,xv,'r.')
plt.xlabel('tiempo [s]')
plt.ylabel('$x[t_k]$')

plt.subplot(122)
plt.plot(tv,yv,'b.')
plt.xlabel('tiempo [s]')
plt.ylabel('$y[t_k]$')
plt.subplots_adjust(hspace=0.5,wspace=0.5)
plt.show()

"""# Ejercicio:

- Después de acondicionar las señales ilustradas en el presente cuaderno, simule un proceso de discretización con $F_s \geq 2 F_o.$ Dibuje el resultado de la señal discretizada utilizando la función [stem](https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.stem.html).

- Consultar el funcionamiento de los métodos [cdist](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html) y [argmin](https://numpy.org/doc/stable/reference/generated/numpy.argmin.html).

- Realice una función mediante el ambiente def que permita realizar los procesos de discretización y cuantización (usando cdist y argmin) en cascada para un conversor análogo-digital de 3 bits con entrada análoga de 0 a 10 [v]. Presente las gráficas de la señal original, señal con cero y pendiente, señal discretizada, y señal digital.

**Ayuda para el ejercicio**: a continuación se presenta el funcionamiento de

1.   Elemento de lista
2.   Elemento de lista

las funciones cdist y argmin
"""

#Ejemplo de señal despues de cero y pendiente y discretización
#Recuerde que el proceso de discretización debe ser implementado
from scipy.spatial.distance import cdist

#señal original
Fo = 60
To = 1/60
A = 120
Fs = 10*Fo #asegurar nyquist
Ts = 1/Fs
tv = np.arange(0,2*To,Ts)#procesar dos periodos discretizados
y = A*np.sin(2*np.pi*Fo*tv)

#cero y pendiente
ycs = my_ceropen(y, ymin=0,ymax=10)

#número de bits y vector de cuantización
nbits = 3
rmin = 0
rmax = 10
ve = np.linspace(rmin,rmax,2**nbits) # (rmax-rmin)/(2^#bits - 1) -> si se quiere incluir rmin y rmax

#distancias y cero pendiente a vector cuantizacion
d = cdist(ycs.reshape(-1,1),ve.reshape(-1,1)) #se utiliza reshape(-1,1) para generar vectores columna como lo pide cdist
d.shape # d es una matriz de 500 x 8, ej: la fila 1 incluye la distancia euclidea entre y[0] y los 8 elementos en ve

#se requiere identificar el elemento ve[j] más cercano a y[i] para genera señal cuantizada
ind = np.argmin(d,axis=1) #el parámetro axis = 1 indica que busca la posición a lo largo de las columnas del elemento más pequeño en cada fila
ind

print(ycs[1],ind[1],ve[ind[1]]) # para y[50] = 0.58, el estado más cercano en ve es el elemento 1 que corresponde a ve[1]=0.71

"""Podemos crear una función de cuantización y evaluarla punto a punto a partir de cada muestra después de cero y spam discretizada"""

#función cuantización punto a punto

def my_cuantizador(yn, vq) : #yn punto a #cuantizar, vq vector de estados

  Ne = vq.shape[0] #tamaño vector de estados
  dn = cdist(yn.reshape(-1,1),vq.reshape(-1,1))#distancia yn a vector estados, reshape(-1,1) asegura vectores columna para poder utilizar cdist
  ind = np.argmin(dn) #posición distancia min
  return vq[ind]

#recorrer vector cero y spam discretizado para cuantizar

for i in range(ycs.shape[0]):
   if i==0: #primera muestra
     yq = my_cuantizador(ycs[i],ve)
   else:
     yq = np.append(yq,my_cuantizador(ycs[i],ve)) #apilar datos cuantizando si i>0

#graficar señales

plt.plot(tv,ycs,c='r', label='ycs')#cs continua

plt.stem(tv,ycs, label='ycs_dis')#cs discreta

#estados de cuantización

for v in ve:
  plt.plot(tv,v*np.ones(len(tv)))

# graficar señal Digital (discreta + cuantizada)

plt.plot(tv,yq,c='y',marker='o',label='ydig', linewidth=2)

plt.legend()
plt.grid()
plt.xlabel('t')
plt.ylabel('Amplitud')
plt.show()

# Ejercicio de clase

from scipy.spatial.distance import cdist

#señal original
#señal 1
Fo = 16
To = 1/16
A = 200
Fs = 10*Fo #asegurar nyquist
Ts = 1/Fs
tv = np.arange(0,2*To,Ts) #procesar dos periodos discretizados
y = A*np.sin(2*np.pi*Fo*tv)

#cero y pendiente
ycs = my_ceropen(y, ymin=-3.3,ymax=3.3)

#número de bits y vector de cuantización
nbits = 4
rmin = 0
rmax = 10
ve = np.linspace(rmin,rmax,2**nbits) # (rmax-rmin)/(2^#bits - 1) -> si se quiere incluir rmin y rmax

#distancias y cero pendiente a vector cuantizacion
d = cdist(ycs.reshape(-1,1),ve.reshape(-1,1)) #se utiliza reshape(-1,1) para generar vectores columna como lo pide cdist
d.shape # d es una matriz de 500 x 8, ej: la fila 1 incluye la distancia euclidea entre y[0] y los 8 elementos en ve

#se requiere identificar el elemento ve[j] más cercano a y[i] para genera señal cuantizada
ind = np.argmin(d,axis=1) #el parámetro axis = 1 indica que busca la posición a lo largo de las columnas del elemento más pequeño en cada fila
ind

## ejercicio

import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial.distance import cdist

# Definición de la señal
Fo_cos = 100 / (2 * np.pi)  # Frecuencia del coseno en Hz
Fo_sin = 200 / (2 * np.pi)  # Frecuencia del seno en Hz
To = 1 / min(Fo_cos, Fo_sin)  # Período de la señal completa
A_cos = 200
A_sin = 50
Fs = 10 * max(Fo_cos, Fo_sin)  # Asegurar Nyquist
Ts = 1 / Fs
tv = np.arange(0, 2 * To, Ts)  # Procesar dos periodos discretizados

# Señal original
y = A_cos * np.cos(100 * tv) - A_sin * np.sin(200 * tv + 5)

# Función para aplicar cero y pendiente
def my_ceropen(y, ymin=0, ymax=10):
    y_normalized = (y - min(y)) / (max(y) - min(y))  # Normalizar la señal
    ycs = y_normalized * (ymax - ymin) + ymin
    return ycs

# Cero y pendiente a la señal original
ycs = my_ceropen(y, ymin=0, ymax=10)

# Número de bits y vector de cuantización
nbits = 3
rmin = 0
rmax = 10
ve = np.linspace(rmin, rmax, 2**nbits)  # Vector de cuantización

# Función de cuantización
def my_cuantizador(yn, vq):
    dn = cdist(yn.reshape(-1, 1), vq.reshape(-1, 1))  # Distancia a vector de estados
    ind = np.argmin(dn)  # Posición distancia mínima
    return vq[ind]

# Cuantización de la señal
yq = []
for i in range(ycs.shape[0]):
    if i == 0:
        yq.append(my_cuantizador(ycs[i], ve))
    else:
        yq.append(my_cuantizador(ycs[i], ve))
yq = np.array(yq)

# Graficar señales
plt.plot(tv, ycs, c='r', label='ycs')  # Señal continua con cero y pendiente
plt.stem(tv, ycs, label='ycs_dis')  # Señal discreta

# Estados de cuantización
for v in ve:
    plt.plot(tv, v * np.ones(len(tv)), 'k--')

# Graficar señal digital (discreta + cuantizada)
plt.plot(tv, yq, c='y', marker='o', label='ydig', linewidth=2)

plt.legend()
plt.grid()
plt.xlabel('t')
plt.ylabel('Amplitud')
plt.show()

# Para entrada de -3.3 a 3.3 y 4 bits

import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial.distance import cdist

# Definición de la señal
Fo_cos = 100 / (2 * np.pi)  # Frecuencia del coseno en Hz
Fo_sin = 200 / (2 * np.pi)  # Frecuencia del seno en Hz
To = 1 / min(Fo_cos, Fo_sin)  # Período de la señal completa
A_cos = 200
A_sin = 50
Fs = 10 * max(Fo_cos, Fo_sin)  # Asegurar Nyquist
Ts = 1 / Fs
tv = np.arange(0, 2 * To, Ts)  # Procesar dos periodos discretizados

# Señal original
y = A_cos * np.cos(100 * tv) - A_sin * np.sin(200 * tv + 5)

# Función para aplicar cero y pendiente
def my_ceropen(y, ymin=-3.3, ymax=3.3):
    y_normalized = (y - min(y)) / (max(y) - min(y))  # Normalizar la señal
    ycs = y_normalized * (ymax - ymin) + ymin
    return ycs

# Cero y pendiente a la señal original
ycs = my_ceropen(y, ymin=-3.3, ymax=3.3)

# Número de bits y vector de cuantización
nbits = 4
rmin = -3.3
rmax = 3.3
ve = np.linspace(rmin, rmax, 2**nbits)  # Vector de cuantización

# Función de cuantización
def my_cuantizador(yn, vq):
    dn = cdist(yn.reshape(-1, 1), vq.reshape(-1, 1))  # Distancia a vector de estados
    ind = np.argmin(dn)  # Posición distancia mínima
    return vq[ind]

# Cuantización de la señal
yq = []
for i in range(ycs.shape[0]):
    if i == 0:
        yq.append(my_cuantizador(ycs[i], ve))
    else:
        yq.append(my_cuantizador(ycs[i], ve))
yq = np.array(yq)

# Graficar señales
plt.plot(tv, ycs, c='r', label='ycs')  # Señal continua con cero y pendiente
plt.stem(tv, ycs, label='ycs_dis')  # Señal discreta

# Estados de cuantización
for v in ve:
    plt.plot(tv, v * np.ones(len(tv)), 'k--')

# Graficar señal digital (discreta + cuantizada)
plt.plot(tv, yq, c='y', marker='o', label='ydig', linewidth=2)

plt.legend()
plt.grid()
plt.xlabel('t')
plt.ylabel('Amplitud')
plt.show()